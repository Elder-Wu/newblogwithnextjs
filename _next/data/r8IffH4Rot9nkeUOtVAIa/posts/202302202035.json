{"pageProps":{"postDetail":{"id":"202302202035","contentHtml":"<h1>购买Debian服务器后，一些准备工作</h1>\n<ol>\n<li><code>apt update &#x26;&#x26; apt upgrade &#x26;&#x26; apt dist-upgrade</code>更新系统\n第一条命令更新可用的软件包列表，第二条命令安装可用的软件包更新，第三条命令处理软件包依赖关系，安装任何新的依赖项，删除任何不再需要的软件包</li>\n<li>在服务器上创建文件<code>/root/.ssh/authorized_keys</code>,然后在本地电脑上执行命令<code>scp ~/.ssh/id_rsa.pub root@server.noname.casa:/root/.ssh/authorized_keys</code>。这句命令的作用是将id_rsa.pub中的内容复制到远程服务器上，如果不行，就手动复制。配置成功后，就不用每次输密码登陆服务器了。</li>\n<li>安装常用的工具<code>apt install htop curl fd-find tldr</code></li>\n<li>安装docker，官方教程https://docs.docker.com/engine/install/debian/，安装好用检查开机自启动有没有配置\n<pre><code>systemctl is-enabled docker\n</code></pre>\n</li>\n<li>用vi 打开/etc/vim/vimrc.tiny，输入以下两行：\nset nocompatible\nset backspace=2\n因为Debian下Vi编辑器，文本输入模式时，不能正确使用方向键和退格键</li>\n<li>执行<code>dpkg-reconfigure tzdata</code>设置时区，然后查看/etc/timezone显示的时间是否是你刚才设置的时区，如果不是，就将刚才设置的时区写入到这个文件，比如<code>echo \"Asia/Shanghai\" > /etc/timezone</code>，最后执行dpkg-reconfigure tzdata重新加载时区</li>\n<li>如果有需要同步的文件，使用如下命令将本地文件夹推送到服务器\n<pre><code># 把本地srcdir目录推送到服务器的/home目录下\nscp -r /srcdir root@[服务器域名或IP]:/home/\n</code></pre>\n如果只是上传文件就不需要<code>-r</code>参数</li>\n</ol>\n<h1>开启BBR加速</h1>\n<blockquote>\n<p>BBR（Bottleneck Bandwidth and Round-trip propagation time）是一种由Google开发的网络拥塞控制算法，BBR算法通过动态调整拥塞窗口大小和传输速度，更好地利用网络带宽，同时减少网络延迟，从而实现网络加速的效果</p>\n</blockquote>\n<ol>\n<li><code>uname -r</code>查看当前的linux内核版本号，如果版本号大于4.9，直接跳到第四步</li>\n<li><code>apt-cache search linux-image | grep $(uname -r)</code>搜索与当前内核版本号匹配的BBR模块，如果没有打印结果，就手动将这两个命令分开来执行。因为随着时间的推移，文件命名规则有可能会改变</li>\n<li>使用apt安装刚才找到的模块</li>\n<li>打开文件<code>vi /etc/sysctl.conf</code>，然后输入这两行，并wq保存退出\n<pre><code>net.core.default_qdisc=fq\nnet.ipv4.tcp_congestion_control=bbr\n</code></pre>\n</li>\n<li>执行<code>sysctl -p</code></li>\n<li>用<code>sysctl net.ipv4.tcp_congestion_control</code>，查看输出结果\n<pre><code>net.ipv4.tcp_congestion_control = bbr\n</code></pre>\n输出这个表示配置成功</li>\n</ol>\n<h1>使用Docker搭建nginx端口转发</h1>\n<h2>nginx配置文件 default.conf</h2>\n<blockquote>\n<p>301 重定向</p>\n</blockquote>\n<pre><code>server {\n    listen 80;\n    listen [::]:80;\n    server_name [这里填域名];\n\n    # 写成具体的网址或者具体的IP地址比较好，避免出现一些问题\n    return 301 https://[这里填域名]$request_uri;\n}\nserver {\n    listen 443;\n    listen [::]:443;\n    server_name [这里填域名];\n\n    ssl_certificate /etc/nginx/ssl/fullchain.pem;\n    ssl_certificate_key /etc/nginx/ssl/privatekey.pem;\n\n    location / {\n        # 运行容器时，需要将nginx的network设置成host模式\n        # 否则，这里的localhost代表nginx容器的127.0.0.1，等于是nginx容器自己转发给自己\n        # 这个问题折磨了我一整晚，一直以为是防火墙的问题\n        proxy_pass http://localhost:[目的端口号];\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n</code></pre>\n<blockquote>\n<p>https访问</p>\n</blockquote>\n<pre><code>server {\n    listen 80;\n    listen [::]:80;\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n    server_name [这里填域名];\n\n    ssl_certificate /etc/nginx/ssl/fullchain.pem;\n    ssl_certificate_key /etc/nginx/ssl/privatekey.pem;\n\n    location / {\n        proxy_pass http://localhost:[目的端口号];\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n</code></pre>\n<blockquote>\n<p>设置nginx默认规则</p>\n</blockquote>\n<pre><code># 默认拒绝连接\nserver {\n    listen 80 default_server;\n    listen 443 default_server;\n    server_name _; #下划线表示没有匹配到规则的主机名\n\n    ssl_certificate /etc/nginx/ssl/fullchain.pem;\n    ssl_certificate_key /etc/nginx/ssl/privatekey.pem;\n\n    return 404;\n}\n</code></pre>\n<h2>nginx_logrotate.conf</h2>\n<pre><code>/var/log/nginx/*.log {\n    daily\n    rotate 7\n    compress\n    delaycompress\n    missingok\n    notifempty\n}\n</code></pre>\n<h2>容器启动脚本 start.sh</h2>\n<pre><code>docker run -d \\\n        --name nginx \\\n        --restart=always \\\n        --network host \\\n        -e TZ=Asia/Shanghai \\\n        -v ${PWD}/ssl/fullchain.pem:/etc/nginx/ssl/fullchain.pem \\\n        -v ${PWD}/ssl/privatekey.pem:/etc/nginx/ssl/privatekey.pem \\\n        -v ${PWD}/default.conf:/etc/nginx/conf.d/default.conf:ro \\\n        -v ${PWD}/nginx_logrotate.conf:/etc/logrotate.d/nginx:ro \\\n        -v ${PWD}/nginx_logs:/var/log/nginx \\\n        nginx:alpine\n</code></pre>\n<ul>\n<li><code>--name</code> 容器名字</li>\n<li><code>--restart</code> 总是重启</li>\n<li><code>--network</code> 设置为<code>host</code>模式，方便nginx进行端口转发，如果不用host模式，在nginx容器内部做端口转发，就比较麻烦，需要知道每个容器的IP地址才行</li>\n<li><code>-e</code> 设置环境变量，将时区设置成Asia/Shanghai</li>\n<li><code>fullchain.pem</code>和<code>privatekey.pem</code>是ssl证书，从注册域名的网站可以获取</li>\n<li><code>default.conf</code>nginx的端口转发配置文件</li>\n<li><code>nginx_logrotate.conf</code> 日志轮转，达到定期清理日志的作用</li>\n<li><code>nginx_logs</code> 日志文件夹，方便查看日志</li>\n</ul>\n<h2>将以上所有文件准备好，目录结构如下</h2>\n<pre><code>--default.conf\n--nginx_logrotate.conf\n--nginx_logs\n--ssl\n----fullchain.pem\n----privatekey.pem\n--start.sh\n</code></pre>\n<h2>运行以后直接在default.conf中添加/删除端口转发规则就好了</h2>\n<h1>如果要把服务器托管到cdn，有以下几个步骤</h1>\n<ol>\n<li>选择一个信得过的cdn服务商</li>\n<li>在cdn服务商的后台管理页面，把你的ssl证书上传上去。可以理解为，此时你的网站已经全权由cdn代理服务器接管了。“云对象存储”也是相同的道理，cdn提供商需要替你解析客户端发过来的http包，只有这样才能代理你的请求。好处就是给自己的服务器减轻压力，缺点就是你的数据全部透明了。</li>\n<li>使用cdn代理时，最好设置下静态资源的cache-control，时间设置长一点。另外cloudflare上也要增加一条页面规则：缓存级别-缓存所有内容</li>\n</ol>\n","title":"Debian服务器","date":"2023-02-20 20:35:44","cover":null,"category":["编程"]}},"__N_SSG":true}