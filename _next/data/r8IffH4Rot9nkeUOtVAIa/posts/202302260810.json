{"pageProps":{"postDetail":{"id":"202302260810","contentHtml":"<h1>运行一个容器</h1>\n<pre><code>docker run -d -it \\\n    --entrypoint [path] \\\n    --name [container-name] \\\n    --restart always \\\n    --rm \\\n    -e TZ=Asia/Shanghai \\\n    --user [UID:PID] \\\n    -v [local/file/path]:[container/file/path] \\\n    -w [work directory] \\\n    [the-image-you-will-run] [cmd-command]\n</code></pre>\n<ul>\n<li><code>-d</code> Run container in background and print container ID</li>\n<li><code>-it</code> 进入交互模式并分配tty</li>\n<li><code>--entrypoint</code> 与[cmd-command]可结合使用</li>\n<li><code>--name</code> container name</li>\n<li><code>--restart</code> 设置是否自动重启</li>\n<li><code>--rm</code> 容器退出时自动删除实例</li>\n<li><code>-e</code> 如果是运行在服务器上，需要将时区的环境变量设置成中国时区，否则会默认使用UTC时区</li>\n<li><code>--user</code> 指定容器运行时的用户</li>\n<li><code>-v</code> 挂载数据卷必须保证主机上的挂载目录或文件存在！</li>\n<li><code>-w</code> 指定工作目录，即“当前目录”</li>\n<li><code>cmd-commond</code> 如果有多个命令时，需要用<code>sh -c</code>,命令用<strong>双引号</strong>扩起来，例如：<code>sh -c \"cd dir &#x26;&#x26; python app.py\"</code></li>\n</ul>\n<h1><code>docker exec</code>对正在运行的Docker容器执行命令</h1>\n<pre><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n</code></pre>\n<h3>OPTIONS是可选的选项，包括：</h3>\n<ul>\n<li><code>-d</code> 启用守护模式。</li>\n<li><code>-i</code> 保持STDIN打开，即使未附加。</li>\n<li><code>-t</code> 分配一个伪TTY。</li>\n<li><code>-u</code> 指定要使用的用户或UID。</li>\n<li><code>-e</code> 设置环境变量。</li>\n</ul>\n<blockquote>\n<p>执行nginx容器的sh命令并分配tty</p>\n</blockquote>\n<pre><code>docker exec -it nginx sh\n</code></pre>\n<blockquote>\n<p>如果需要在容器中执行多个命令，也可以将多个命令组合在一起使用</p>\n</blockquote>\n<pre><code>docker exec -it mycontainer sh -c \"command1 &#x26;&#x26; command2\"\n</code></pre>\n<h1>查看容器终端output日志</h1>\n<pre><code>docker logs [OPTIONS] CONTAINER\n</code></pre>\n<h3>可选参数</h3>\n<ul>\n<li><code>--details</code>     Show extra details provided to logs</li>\n<li><code>-f, --follow</code>  Follow log output</li>\n</ul>\n<h1>Dockerfile配置</h1>\n<ul>\n<li><code>FROM</code></li>\n<li><code>MAINTAINER</code></li>\n<li><code>RUN</code> 构建镜像执行的命令，每一次RUN都会构建一层</li>\n<li><code>ENTRYPOINT</code> 容器进入时执行的命令</li>\n<li><code>CMD</code> 容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参\n<blockquote>\n<p>推荐exec模式，运行效率高。但如果要使用shell中的某个特殊字符，就必须要用shell模式运行，比如管道符<code>|</code>、通配符<code>*</code>和变量<code>$</code>等</p>\n</blockquote>\n<pre><code># exec模式\n# 用中括号扩起来不经过shell解释器，直接运行命令\nCMD [\"gunicorn\",\"-b\",\"127.0.0.1:8000\",\"app:app\"]\n# shell模式\n# 命令会被shell解释器进程执行，用ps命令可以看到shell是父进程，而我们要运行的命令是fork的子进程\nCMD ./alist server\n</code></pre>\n</li>\n<li><code>VOLUME</code> 定义数据卷，如果没有定义则使用默认</li>\n<li><code>USER</code> 指定执行的用户组和用户</li>\n<li><code>WORKDIR</code> 切换当前执行的工作目录</li>\n<li><code>HEALTHCHECH</code> 健康检测指令</li>\n<li><code>ARG</code> 变量属性值，但不在容器内部起作用</li>\n<li><code>EXPOSE</code> 暴露端口</li>\n<li><code>ENV</code> 变量属性值，容器内部也会起作用</li>\n<li><code>ADD</code> 添加文件，如果是压缩文件也解压</li>\n<li><code>COPY</code> 添加文件，以复制的形式</li>\n</ul>\n<h1>构建镜像</h1>\n<pre><code>docker build -t [name:tag] .\n</code></pre>\n<ul>\n<li><code>-t</code> Name and optionally a tag in the name:tag</li>\n<li><code>.</code> Dockerfile in current directory,otherwith you have to specify a Dockerfile use <code>-f</code></li>\n</ul>\n<h1>容器启动/停止/重新启动</h1>\n<pre><code>docker start [container]\ndocker stop [container]\ndocker restart [container]\n</code></pre>\n<h1>容器运行状态查看</h1>\n<pre><code>docker stats #查看每个容器的cpu和内存还有网络情况\ndocker top [CONTAINER] #查看容器内部的进程\n</code></pre>\n<h1>容器删除/镜像删除</h1>\n<pre><code># 删除容器\ndocker rm -f [container]\n# 删除镜像\ndocker rmi -f [container]\n</code></pre>\n<h1>清理 cleanup</h1>\n<pre><code>docker system prune -a --volumes\n</code></pre>\n<h1>命令提示</h1>\n<p></p>\n<h1>Alpine镜像</h1>\n","title":"Docker容器","date":"2023-02-26 08:10:08","cover":null,"category":["编程"]}},"__N_SSG":true}